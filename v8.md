## 新版本的 V8

1. parser 解析器 生成 AST 抽象语法树
2. interpreter 解释器 Ignition 生成 byteCode 字节码 并直接执行
3. 清除 AST 释放内存空间
4. 得到 25% - 50%的等效机器代码大小
5. compiler 运行过程中，解释器收集优化信息发送给编译器 TurboFan
6. 重新生成机器码
7. 有些热点函数变更会由优化后的机器码还原成字节码 也就是 deoptimization 回退字节码操作执行

优化点：

1. 值声明未调用，不会被解析生成 AST
2. 函数只被调用一次，bytcode 直接被解释执行，不会进入到编译优化阶段
3. 函数被调用多次，Igniton 会收集函数类型信息，可能会被标记为热点函数，可能被编译成优化后的机器代码

好处：

1. 由于一开始不需要直接编译成机器码，生成了中间层的字节码，从而节约了时间
2. 优化编译阶段，不需要从源码重新解析,直接通过字节码进行优化，也可以 deoptimization 回退操作

```javascript
function sum(x, y) {
  return x + y
}
sum(1, 2)
sum(3, 4)
sum(5, 6)
sum('7', '8') //会回退字节码操作执行
```
